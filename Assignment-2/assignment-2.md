# CS 4391 – Spring 2026

## Assignment 2 – Image Filtering

**Due Date:** Mar 8th, 2026 – 11:59 PM

---

In this assignment, you will be implementing some basic filters to images and record the result image.

Many of the algorithms you will be implementing as part of this assignment are functions in **OpenCV (Open Computer Vision Library)**.

You are **NOT allowed** to use (call) these functions in this assignment, unless otherwise specified.

You may, however, compare your output to the output generated by these functions to make sure you are on the right track.

You can choose either **C++ or Python** for the implementation of the program.

For the given image in this assignment, please apply the following filters and save all the output results (save the output images):

---

## Filters to Implement

---

### a. 7 × 7 Box Blur Filter

---

### b. 15 × 15 Gaussian Filter

Use the following code to generate the filter:

```python
import numpy as np
import cv2

# Size must be odd
kernel_size = 15
# Sigma controls the 'spread' of the blur
sigma = 4.0

# Generate 1D Gaussian kernel
kernel1d = cv2.getGaussianKernel(kernel_size, sigma)

# Generate 2D Gaussian kernel by multiplying 1D kernels
kernel2d = np.outer(kernel1d, kernel1d)

print(kernel2d)
```

---

### c. 15 × 15 Motion Blur Filter

Use the following code to generate the diagonal motion blur filter:

```python
import numpy as np
import cv2

size = 15

# Create a 15x15 matrix of zeros
kernel = np.zeros((size, size))

# Fill the main diagonal with 1s
np.fill_diagonal(kernel, 1)

# Normalize the kernel so the sum is 1
kernel = kernel / size
```

---

### d. 3 × 3 Laplacian Sharpening Filter

Use the following filter:

```python
kernel = np.array([
    [-1, -1, -1],
    [-1,  9, -1],
    [-1, -1, -1]
])
```

---

### e. Canny Edge Detection Filter

---

#### i. Use 5 × 5 Gaussian Filter first to smooth the image

Use the following Gaussian kernel:

```
K = (1/159) *  |  2   4   5   4   2 |
               |  4   9  12   9   4 |
               |  5  12  15  12   5 |
               |  4   9  12   9   4 |
               |  2   4   5   4   2 |
```

---

#### ii. Use Sobel Kernels

Horizontal Sobel kernel (Gx) (Detects vertical edges):

```
Gx = | -1   0   1 |
     | -2   0   2 |
     | -1   0   1 |
```

Vertical Sobel kernel (Gy) (Detects horizontal edges):

```
Gy = | -1  -2  -1 |
     |  0   0   0 |
     |  1   2   1 |
```

Then calculate the **magnitude and direction** for each pixel:

```
M     = sqrt(Gx^2 + Gy^2)
theta = arctan(Gy / Gx)
```

---

#### iii. Non-Maximum Suppression

“Thin” the detected edges down to a single pixel width.

For each pixel, the algorithm checks if its gradient magnitude is a **local maximum in its gradient direction**.
If not, the pixel value is set to zero.

---

#### iv. Thresholding

Apply thresholding to determine strong and weak edges.

---

## Submission Instructions

Please submit your **source code and result images** to **eLearning ONLY**.

**Do NOT submit your project or other files.**
